name: Deploy to Amazon Linux EC2 (compose-prod)

on:
  push:
    branches: [ main ]   # main 브랜치 푸시 시 배포
  workflow_dispatch: {}

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      # 1) 코드 체크아웃
      - name: Checkout
        uses: actions/checkout@v4

      # 2) JDK 설치 후 JAR 빌드
      - name: Set up JDK
        uses: actions/setup-java@v4
        with:
          java-version: '17'
          distribution: 'temurin'

      - name: Build with Gradle
        run: ./gradlew clean build -x test
        working-directory: backendProject

      # (디버그) Rename JAR 직전: 현재 위치와 산출물 확인
      - name: Debug working dir & artifacts
        run: |
          set -euxo pipefail
          echo "PWD=$(pwd)"
          ls -al
          echo "=== build/libs ==="
          ls -al build/libs || true
        working-directory: backendProject

      # Rename JAR: 'plain' 제외하고 단일 JAR만 app.jar로 복사
      - name: Rename JAR
        run: |
          set -euo pipefail
          # 우선순위: -plain 제거 → 가장 최신 JAR 1개 선택
          JAR_FILE=$(ls -t build/libs/*.jar | grep -v '\-plain\.jar$' | head -n 1 || true)
          if [ -z "${JAR_FILE:-}" ]; then
            # 만약 -plain만 있다면 그 중 최신 1개 선택
            JAR_FILE=$(ls -t build/libs/*.jar | head -n 1)
          fi
          echo "Selected JAR: $JAR_FILE"
          cp "$JAR_FILE" app.jar
          ls -al app.jar
        working-directory: backendProject

      # 4) EC2로 파일 업로드 (JAR, docker-compose-prod.yml, Dockerfile, .env)
      - name: Upload files to EC2
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USER }}
          key: ${{ secrets.EC2_SSH_KEY }}
          source: |
            backendProject/app.jar
          target: ${{ secrets.EC2_APP_DIR }}

      # 5) EC2에서 Docker Compose 실행
      - name: Deploy on EC2
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USER }}
          key: ${{ secrets.EC2_SSH_KEY }}
          script: |
            set -e
            APP_DIR="${{ secrets.EC2_APP_DIR }}"
            cd "$APP_DIR"

            # Docker 설치 확인
            if ! command -v docker >/dev/null 2>&1; then
              if command -v dnf >/dev/null 2>&1; then
                sudo dnf -y update
                sudo dnf -y install docker
              else
                sudo yum -y update
                sudo yum -y install docker
              fi
              sudo systemctl enable docker
              sudo systemctl start docker
              sudo usermod -aG docker ec2-user || true
            fi

            # docker-compose 설치 확인
            if ! command -v docker-compose >/dev/null 2>&1; then
              sudo curl -SL https://github.com/docker/compose/releases/download/v2.29.7/docker-compose-linux-x86_64 -o /usr/local/bin/docker-compose
              sudo chmod +x /usr/local/bin/docker-compose
            fi

            # 기존 컨테이너 중지 후 새 빌드 실행
            sudo docker-compose -f docker-compose-prod.yml down || true
            sudo docker-compose -f docker-compose-prod.yml up -d --build
            sudo docker image prune -f

      # 6) (선택) CloudFront 캐시 무효화
      - name: Set CloudFront ID as env var
        run: echo "CF_ID=${{ secrets.CF_DISTRIBUTION_ID }}" >> $GITHUB_ENV

      - name: Configure AWS credentials
        if: env.CF_ID != ''
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Invalidate CloudFront
        if: env.CF_ID != ''
        run: |
          aws cloudfront create-invalidation \
            --distribution-id "${{ env.CF_ID }}" \
            --paths "/*"
